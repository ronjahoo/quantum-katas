<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Quantum.Simulation.Common</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Quantum.Simulation.Common.Factory`1">
            <summary>
                A Base class for Factories used to create and manage instances
                of objects of certain type.
                It takes on creating new instances and caching them.
                It also provides a mechanism to register overrides when a given
                type should be replaced by a subclass.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.Factory`1.Register(System.Type,System.Type,System.Type)">
            <summary>
            Register an override for the given operation.
            The original Type must be a subclass of Operation, and the replacement Type must be a 
            subclass of the Type it is overriding, otherwise an ArgumentException is thrown.
            It also throws an Exception if either of the parameters is null.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.Factory`1.CanCache(`0)">
            <summary>
            Used to determine if the given instance should be cached.
            By default, all instances are cacheable.
            </summary>
        </member>
        <member name="T:Microsoft.Quantum.Simulation.Common.IQuantumProcessor">
            <summary>
            An interface for implementing QDK target quantum machines that work on a quantum circuit level. 
            </summary>
            <remarks>
            To implement a target machine that executes quantum commands, implement this interface.
            Implementors of <see cref="T:Microsoft.Quantum.Simulation.Common.IQuantumProcessor"/> interface do not manage qubits on their own.
            All qubit management (allocation, dealocation, etc.) is done by the caller of this interface.
            Implementors are notified when qubits are allocated, released, borrowed and returned allowing them to react to these events if necessary.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.X(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.x">Microsoft.Quantum.Intrinsic.X</a> is called in Q#.
            When this is invoked, it is expected that the X gate gets applied to the given <paramref name="qubit"/>. The gate is given by matrix X=((0,1),(1,0)).
            </summary>
            <remarks>
            When adjoint of X is called in Q#, this same method is called because X is self-adjoint.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledX(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.x">Microsoft.Quantum.Intrinsic.X</a> is called in Q#.
            When this is invoked, it is expected that the X gate gets applied to the given <paramref name="qubit"/> controlled on <paramref name="controls"/>. The gate is given by matrix X=((0,1),(1,0)).
            </summary>
            <remarks>
            When adjoint of Controlled X is called in Q#, this same method is called because X is self-adjoint.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.Y(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.y">Microsoft.Quantum.Intrinsic.Y</a> is called in Q#.
            When this is invoked, it is expected that the Y gate gets applied to the given <paramref name="qubit"/>. The gate is given by matrix Y=((0,-ğ‘–),(ğ‘–,0)).
            </summary>
            <remarks>
            When adjoint of Y is called in Q#, this same method is called because Y is self-adjoint.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledY(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.y">Microsoft.Quantum.Intrinsic.Y</a> is called in Q#.
            When this is invoked, it is expected that the Y gate gets applied to the given <paramref name="qubit"/> controlled on <paramref name="controls"/>. The gate is given by matrix Y=((0,-ğ‘–),(ğ‘–,0)).
            </summary>
            <remarks>
            When adjoint of Controlled Y is called in Q#, this same method is called because Y is self-adjoint.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.Z(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.z">Microsoft.Quantum.Intrinsic.Z</a> is called in Q#.
            When this is invoked, it is expected that the Z gate gets applied to the given <paramref name="qubit"/>. The gate is given by matrix Z=((1,0),(0,-1)).
            </summary>
            <remarks>
            When adjoint of Z is called in Q#, this same method is called because Z is self-adjoint.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledZ(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.z">Microsoft.Quantum.Intrinsic.Z</a> is called in Q#.
            When this is invoked, it is expected that the Z gate gets applied to the given <paramref name="qubit"/> controlled on <paramref name="controls"/>. The gate is given by matrix Z=((1,0),(0,-1)).
            </summary>
            <remarks>
            When adjoint of Controlled Z is called in Q#, this same method is called because Z is self-adjoint.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.SWAP(Microsoft.Quantum.Simulation.Core.Qubit,Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.swap">Microsoft.Quantum.Intrinsic.SWAP</a> is called in Q#.
            When this is invoked, it is expected that the gate given by rule |ÏˆâŸ©âŠ—|Ï•âŸ© â†¦ |Ï•âŸ©âŠ—|ÏˆâŸ© where |Ï•âŸ©,|ÏˆâŸ© arbitrary one qubit states gets applied.
            </summary>
            <remarks>
            When adjoint of SWAP is called in Q#, this same method is called because SWAP is self-adjoint.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="qubit1">First qubit to be swapped.</param>
            <param name="qubit2">Second qubit to be swapped.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledSWAP(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit,Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.swap">Microsoft.Quantum.Intrinsic.SWAP</a> is called in Q#.
            When this is invoked, it is expected that the gate given by rule |ÏˆâŸ©âŠ—|Ï•âŸ© â†¦ |Ï•âŸ©âŠ—|ÏˆâŸ© where |Ï•âŸ©,|ÏˆâŸ© arbitrary one qubit states gets applied, controlled on <paramref name="controls"/>.
            </summary>
            <remarks>
            When adjoint of Controlled SWAP is called in Q#, this same method is called because SWAP is self-adjoint.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="qubit1">First qubit to be swapped.</param>
            <param name="qubit2">Second qubit to be swapped.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.H(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.h">Microsoft.Quantum.Intrinsic.H</a> is called in Q#.
            When this is invoked, it is expected that the Hadamard gate gets applied to <paramref name="qubit"/>. The gate is given by matrix H=((1,1),(1,-1))/âˆš2.
            </summary>
            <remarks>
            When adjoint of H is called in Q#, this same method is called because Hadamard is self-adjoint.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledH(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.h">Microsoft.Quantum.Intrinsic.H</a> is called in Q#.
            When this is invoked, it is expected that the Hadamard gate gets applied to <paramref name="qubit"/> controlled on <paramref name="controls"/>. The gate is given by matrix H=((1,1),(1,-1))/âˆš2.
            </summary>
            <remarks>
            When adjoint of Controlled H is called in Q#, this same method is called because Hadamard is self-adjoint.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.S(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.s">Microsoft.Quantum.Intrinsic.S</a> is called in Q#.
            When this is invoked, it is expected that the S gate gets applied to <paramref name="qubit"/>. The gate is given by matrix S=((1,0),(0,ğ‘–)).
            </summary>
            <remarks>
            When adjoint of S is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.SAdjoint(Microsoft.Quantum.Simulation.Core.Qubit)"/> is called.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledS(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.s">Microsoft.Quantum.Intrinsic.S</a> is called in Q#.
            When this is invoked, it is expected that the S gate gets applied to <paramref name="qubit"/> controlled on <paramref name="controls"/>. The gate is given by matrix S=((1,0),(0,ğ‘–)).
            </summary>
            <remarks>
            When adjoint of Controlled S is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledSAdjoint(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)"/> is called.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.SAdjoint(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when adjoint <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.s">Microsoft.Quantum.Intrinsic.S</a> is called in Q#.
            When this is invoked, it is expected that the Sâ€  gate gets applied to <paramref name="qubit"/>. The gate is given by matrix Sâ€ =((1,0),(0,-ğ‘–)).
            </summary>
            <remarks>
            When adjoint of Adjoint S is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.S(Microsoft.Quantum.Simulation.Core.Qubit)"/> is called.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledSAdjoint(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled adjoint <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.s">Microsoft.Quantum.Intrinsic.S</a> is called in Q#.
            When this is invoked, it is expected that the Sâ€  gate gets applied to <paramref name="qubit"/> controlled on <paramref name="controls"/>. The gate is given by matrix Sâ€ =((1,0),(0,ğ‘–)).
            </summary>
            <remarks>
            When adjoint of Controlled Sâ€  is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledS(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)"/> is called.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.T(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.t">Microsoft.Quantum.Intrinsic.T</a> is called in Q#.
            When this is invoked, it is expected that the T gate gets applied to <paramref name="qubit"/>. The gate is given by matrix T=((1,0),(0,ğ‘’ğ‘¥ğ‘(ğ‘–â‹…Ï€/4))).
            </summary>
            <remarks>
            When adjoint of T is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.TAdjoint(Microsoft.Quantum.Simulation.Core.Qubit)"/> is called.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledT(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.t">Microsoft.Quantum.Intrinsic.T</a> is called in Q#.
            When this is invoked, it is expected that the T gate gets applied to <paramref name="qubit"/> controlled on <paramref name="controls"/>. The gate is given by matrix T=((1,0),(0,ğ‘’ğ‘¥ğ‘(ğ‘–â‹…Ï€/4))).
            </summary>
            <remarks>
            When adjoint of Controlled T is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledTAdjoint(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)"/> is called.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.TAdjoint(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when adjoint <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.t">Microsoft.Quantum.Intrinsic.T</a> is called in Q#.
            When this is invoked, it is expected that the Tâ€  gate gets applied to <paramref name="qubit"/>. The gate is given by matrix Tâ€ =((1,0),(0,ğ‘’ğ‘¥ğ‘(-ğ‘–â‹…Ï€/4))).
            </summary>
            <remarks>
            When adjoint of Adjoint T is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.T(Microsoft.Quantum.Simulation.Core.Qubit)"/> is called.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledTAdjoint(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled adjoint <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.t">Microsoft.Quantum.Intrinsic.T</a> is called in Q#.
            When this is invoked, it is expected that the Tâ€  gate gets applied to <paramref name="qubit"/> controlled on <paramref name="controls"/>. The gate is given by matrix Tâ€ =((1,0),(0,ğ‘’ğ‘¥ğ‘(-ğ‘–â‹…Ï€/4))).
            </summary>
            <remarks>
            When adjoint of Controlled Tâ€  is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledT(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Qubit)"/> is called.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.R(Microsoft.Quantum.Simulation.Core.Pauli,System.Double,Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r">Microsoft.Quantum.Intrinsic.R</a> is called in Q#.
            When this is invoked, it is expected that the ğ‘’ğ‘¥ğ‘(-ğ‘–â‹…<paramref name="theta"/>â‹…<paramref name="axis"/>/2) gets applied to <paramref name="qubit"/>.  
            </summary>
            <remarks>
            When adjoint of R is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.R(Microsoft.Quantum.Simulation.Core.Pauli,System.Double,Microsoft.Quantum.Simulation.Core.Qubit)"/> is called with <paramref name="theta"/> replaced by -<paramref name="theta"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="axis">Pauli operator to be exponentiated to form the rotation.</param>
            <param name="theta">Angle about which the qubit is to be rotated.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledR(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Pauli,System.Double,Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r">Microsoft.Quantum.Intrinsic.R</a> is called in Q#.
            When this is invoked, it is expected that the ğ‘’ğ‘¥ğ‘(-ğ‘–â‹…<paramref name="theta"/>â‹…<paramref name="axis"/>/2) gets applied to <paramref name="qubit"/> controlled on <paramref name="controls"/>.  
            </summary>
            <remarks>
            When adjoint of Controlled R is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledR(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Pauli,System.Double,Microsoft.Quantum.Simulation.Core.Qubit)"/> is called with <paramref name="theta"/> replaced by -<paramref name="theta"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="axis">Pauli operator to be exponentiated to form the rotation.</param>
            <param name="theta">Angle about which the qubit is to be rotated.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.RFrac(Microsoft.Quantum.Simulation.Core.Pauli,System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.rfrac">Microsoft.Quantum.Intrinsic.RFrac</a> is called in Q#.
            When this is invoked, it is expected that the ğ‘’ğ‘¥ğ‘(ğ‘–â‹…Ï€â‹…<paramref name="numerator"/>â‹…<paramref name="axis"/>/2^<paramref name="power"/>) gets applied to <paramref name="qubit"/>.  
            </summary>
            <remarks>
            When adjoint of RFrac is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.RFrac(Microsoft.Quantum.Simulation.Core.Pauli,System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.Qubit)"/> is called with <paramref name="numerator"/> replaced by -<paramref name="numerator"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="axis">Pauli operator to be exponentiated to form the rotation.</param>
            <param name="numerator">Numerator in the dyadic fraction representation of the angle by which the qubit is to be rotated.</param>
            <param name="power">Power of two specifying the denominator of the angle by which the qubit is to be rotated.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledRFrac(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Pauli,System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when a controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.rfrac">Microsoft.Quantum.Intrinsic.RFrac</a> is called in Q#.
            When this is invoked, it is expected that the ğ‘’ğ‘¥ğ‘(ğ‘–â‹…Ï€â‹…<paramref name="numerator"/>â‹…<paramref name="axis"/>/2^<paramref name="power"/>) gets applied to <paramref name="qubit"/> controlled on <paramref name="controls"/>.
            </summary>
            <remarks>
            When adjoint of Controlled RFrac is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledRFrac(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Pauli,System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.Qubit)"/> is called with <paramref name="numerator"/> replaced by -<paramref name="numerator"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="axis">Pauli operator to be exponentiated to form the rotation.</param>
            <param name="numerator">Numerator in the dyadic fraction representation of the angle by which the qubit is to be rotated.</param>
            <param name="power">Power of two specifying the denominator of the angle by which the qubit is to be rotated.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.R1(System.Double,Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1">Microsoft.Quantum.Intrinsic.R1</a> is called in Q#.
            When this is invoked, it is expected that the gate given by matrix ((1,0),(0,ğ‘’ğ‘¥ğ‘(ğ‘–â‹…<paramref name="theta"/>))) gets applied to <paramref name="qubit"/>.  
            </summary>
            <remarks>
            When adjoint of R1 is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.R1(System.Double,Microsoft.Quantum.Simulation.Core.Qubit)"/> is called with <paramref name="theta"/> replaced by -<paramref name="theta"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="theta">Angle about which the qubit is to be rotated.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledR1(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},System.Double,Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r">Microsoft.Quantum.Intrinsic.R</a> is called in Q#.
            When this is invoked, it is expected that the gate given by matrix ((1,0),(0,ğ‘’ğ‘¥ğ‘(ğ‘–â‹…<paramref name="theta"/>))) gets applied to <paramref name="qubit"/> controlled on <paramref name="controls"/>.  
            </summary>
            <remarks>
            When adjoint of Controlled R1 is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledR1(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},System.Double,Microsoft.Quantum.Simulation.Core.Qubit)"/> is called with <paramref name="theta"/> replaced by -<paramref name="theta"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="theta">Angle about which the qubit is to be rotated.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.R1Frac(System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1frac">Microsoft.Quantum.Intrinsic.R1Frac</a> is called in Q#.
            When this is invoked, it is expected that the gate given by matrix ((1,0),(0,ğ‘’ğ‘¥ğ‘(ğ‘–â‹…Ï€â‹…<paramref name="numerator"/>/2^<paramref name="power"/>))) gets applied to <paramref name="qubit"/>.  
            </summary>
            <remarks>
            When adjoint of R1Frac is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.R1Frac(System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.Qubit)"/> is called with <paramref name="numerator"/> replaced by -<paramref name="numerator"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="numerator">Numerator in the dyadic fraction representation of the angle by which the qubit is to be rotated.</param>
            <param name="power">Power of two specifying the denominator of the angle by which the qubit is to be rotated.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledR1Frac(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when a controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1frac">Microsoft.Quantum.Intrinsic.R1Frac</a> is called in Q#.
            When this is invoked, it is expected that the gate given by matrix ((1,0),(0,ğ‘’ğ‘¥ğ‘(ğ‘–â‹…Ï€â‹…<paramref name="numerator"/>/2^<paramref name="power"/>))) gets applied to <paramref name="qubit"/> controlled on <paramref name="controls"/>.
            </summary>
            <remarks>
            When adjoint of Controlled RFrac is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledR1Frac(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.Qubit)"/> is called with <paramref name="numerator"/> replaced by -<paramref name="numerator"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="numerator">Numerator in the dyadic fraction representation of the angle by which the qubit is to be rotated.</param>
            <param name="power">Power of two specifying the denominator of the angle by which the qubit is to be rotated.</param>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.Exp(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},System.Double,Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.exp">Microsoft.Quantum.Intrinsic.Exp</a> is called in Q#.
            When this is invoked, it is expected that the ğ‘’ğ‘¥ğ‘(ğ‘–â‹…<paramref name="theta"/>â‹…<paramref name="paulis"/>) gets applied to <paramref name="qubits"/>.  
            </summary>
            <remarks>
            When adjoint of Exp is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.Exp(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},System.Double,Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})"/> is called with <paramref name="theta"/> replaced by -<paramref name="theta"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="paulis">Array of single-qubit Pauli values representing a multi-qubit Pauli to be applied.</param>
            <param name="theta">Angle about the given multi-qubit Pauli operator by which the target register is to be rotated.</param>
            <param name="qubits">Register to apply the exponent to.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledExp(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},System.Double,Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Called when a controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.exp">Microsoft.Quantum.Intrinsic.Exp</a> is called in Q#.
            When this is invoked, it is expected that the ğ‘’ğ‘¥ğ‘(ğ‘–â‹…<paramref name="theta"/>â‹…<paramref name="paulis"/>) gets applied to <paramref name="qubits"/> controlled on <paramref name="controls"/>.  
            </summary>
            <remarks>
            When adjoint of Controlled Exp is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledExp(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},System.Double,Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})"/> is called with <paramref name="theta"/> replaced by -<paramref name="theta"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="paulis">Array of single-qubit Pauli values representing a multi-qubit Pauli to be applied.</param>
            <param name="theta">Angle about the given multi-qubit Pauli operator by which the target register is to be rotated.</param>
            <param name="qubits">Register to apply the exponent to.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ExpFrac(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.expfrac">Microsoft.Quantum.Intrinsic.ExpFrac</a> is called in Q#.
            When this is invoked, it is expected that the ğ‘’ğ‘¥ğ‘(ğ‘–â‹…Ï€â‹…<paramref name="numerator"/>â‹…<paramref name="paulis"/>/2^<paramref name="power"/>) gets applied to <paramref name="qubits"/>.
            </summary>
            <remarks>
            When adjoint of ExpFrac is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ExpFrac(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})"/> is called with <paramref name="numerator"/> replaced by -<paramref name="numerator"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="paulis">Array of single-qubit Pauli values representing a multi-qubit Pauli to be applied.</param>
            <param name="numerator">Numerator in the dyadic fraction representation of the angle by which the qubit register is to be rotated.</param>
            <param name="power">Power of two specifying the denominator of the angle by which the qubit register is to be rotated.</param>
            <param name="qubits">Register to apply the exponent to.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledExpFrac(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Called when controlled <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.expfrac">Microsoft.Quantum.Intrinsic.ExpFrac</a> is called in Q#.
            When this is invoked, it is expected that the ğ‘’ğ‘¥ğ‘(ğ‘–â‹…Ï€â‹…<paramref name="numerator"/>â‹…<paramref name="paulis"/>/2^<paramref name="power"/>) gets applied to <paramref name="qubits"/> controlled on <paramref name="controls"/>.
            </summary>
            <remarks>
            When adjoint of Controlled ExpFrac is called in Q#, <see cref="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.ControlledExpFrac(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},System.Int64,System.Int64,Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})"/> is called with <paramref name="numerator"/> replaced by -<paramref name="numerator"/>.
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="controls">The array of qubits on which the operation is controlled.</param>
            <param name="paulis">Array of single-qubit Pauli values representing a multi-qubit Pauli to be applied.</param>
            <param name="numerator">Numerator in the dyadic fraction representation of the angle by which the qubit register is to be rotated.</param>
            <param name="power">Power of two specifying the denominator of the angle by which the qubit register is to be rotated.</param>
            <param name="qubits">Register to apply the exponent to.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.M(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.m">Microsoft.Quantum.Intrinsic.M</a> is called in Q#.
            When this is invoked, it is expected that the <paramref name="qubit"/> is measured in Z basis, in other words in the computational basis.
            </summary>
            <remarks>
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            Class implementing <see cref="T:Microsoft.Quantum.Simulation.Common.IQuantumProcessor"/> interface can return any class derived from <see cref="T:Microsoft.Quantum.Simulation.Core.Result"/>.
            </remarks>
            <param name="qubit">Qubit to which the gate should be applied.</param>
            <returns> Zero if the +1 eigenvalue is observed, and One if the -1 eigenvalue is observed.</returns>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.Measure(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.measure">Microsoft.Quantum.Intrinsic.Measure</a> is called in Q#.
            When this is invoked, it is expected that the multi-qubit Pauli observable given by <paramref name="bases"/> is measured on <paramref name="qubits"/>.
            </summary>
            <remarks>
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            Class implementing <see cref="T:Microsoft.Quantum.Simulation.Common.IQuantumProcessor"/> interface can return any class derived from <see cref="T:Microsoft.Quantum.Simulation.Core.Result"/>.
            </remarks>
            <param name="qubits">Qubits to which the gate should be applied.</param>
            <param name="bases">Array of single-qubit Pauli values describing multi-qubit Pauli observable.</param>
            <returns> Zero if the +1 eigenvalue is observed, and One if the -1 eigenvalue is observed.</returns>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.Reset(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.reset">Microsoft.Quantum.Intrinsic.Reset</a> is called in Q#.
            When this is invoked, it is expected that the <paramref name="qubit"/> is measured and ensured to be in the |0âŸ© state such that it can be safely released.
            </summary>
            <remarks>
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="qubit">Qubit to which the gate should be applied.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.StartConditionalStatement(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Result},Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Result})">
            <summary>
            Intended for a limited support of branching upon measurement results on a target machine level.
            Called when a conditional statement on measurement results is invoked.
            </summary>
            <param name="measurementResults">The actual results of the measurements of a number of qubits upon which branching is to be performed.</param>
            <param name="resultsValues">The expected values of results of the measurements of these qubits.</param>
            <returns> A value representing this conditional statement and encoding the result of condition.</returns>
            <remarks>
            A typical implementation will compare all <paramref name="measurementResults"/> to <paramref name="resultsValues"/> and return the result of this comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.StartConditionalStatement(Microsoft.Quantum.Simulation.Core.Result,Microsoft.Quantum.Simulation.Core.Result)">
            <summary>
            Intended for a limited support of branching upon measurement results on a target machine level.
            Called when a conditional statement on a measurement result is invoked.
            </summary>
            <param name="measurementResult">The actual result of the measurement of a qubit upon which branching is to be performed.</param>
            <param name="resultValue">The expected value of result of the measurement of this qubit.</param>
            <returns> A value representing this conditional statement and encoding the result of the condition. It will be passed through to the other branching related APIs such as RunThenClause.</returns>
            <remarks>
            A typical implementation will compare <paramref name="measurementResult"/> to <paramref name="resultValue"/> and return the result of this comparison.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.RunThenClause(System.Int64)">
            <summary>
            Intended for a limited support of branching upon measurement results on a target machine level.
            Called when the "then" statement of a conditional statement is about to be executed.
            </summary>
            <param name="statement">A value representing this conditional statement and encoding the result of condition.</param>
            <returns> If true is returned, the "then" statement will be executed, otherwise it will be skipped and RepeatThenClause will not be called.</returns>
            <remarks>
            A typical implementation will use <paramref name="statement"/> to return whether condition was evaluated to true.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.RepeatThenClause(System.Int64)">
            <summary>
            Intended for a limited support of branching upon measurement results on a target machine level.
            Called when the "then" statement of a conditional statement has finished executing.
            </summary>
            <param name="statement">A value representing this conditional statement and encoding the result of the condition. This is the value returned from the StartConditionalStatement.</param>
            <returns> If true is returned, the "then" statement will be executed again (without calling RunThenClause), folowed by another call to RepeatThenClause.</returns>
            <remarks>
            A typical implementation will return false.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.RunElseClause(System.Int64)">
            <summary>
            Intended for a limited support of branching upon measurement results on a target machine level.
            Called when the "else" statement of a conditional statement is about to be executed.
            </summary>
            <param name="statement">A value representing this conditional statement and encoding the result of the condition. This is the value returned from the StartConditionalStatement.</param>
            <returns> If true is returned, the "else" statement will be executed, otherwise it will be skipped and RepeatElseClause will not be called.</returns>
            <remarks>
            A typical implementation will use <paramref name="statement"/> to return whether condition was evaluated to false.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.RepeatElseClause(System.Int64)">
            <summary>
            Intended for a limited support of branching upon measurement results on a target machine level.
            Called when the "else" statement of a conditional statement has finished executing.
            </summary>
            <param name="statement">A value representing this conditional statement and encoding the result of the condition. This is the value returned from the StartConditionalStatement.</param>
            <returns> If true is returned, the "else" statement will be executed again (without calling RunElseClause), folowed by another call to RepeatElseClause.</returns>
            <remarks>
            A typical implementation will return false.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.EndConditionalStatement(System.Int64)">
            <summary>
            Intended for a limited support of branching upon measurement results on a target machine level.
            Called when a conditional statement on measurement results has finished executing.
            </summary>
            <param name="statement">A value representing this conditional statement and encoding the result of the condition. This is the value returned from the StartConditionalStatement.</param>
            <remarks>
            A typical implementation will clean up any data structures associated with statement.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.Assert(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.Result,System.String)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.assert">Microsoft.Quantum.Intrinsic.Assert</a> is called in Q#.
            </summary>
            <remarks>
            The names and the order of the parameters are the same as for the corresponding Q# operation.
            </remarks>
            <param name="bases">A multi-qubit Pauli operator, for which the measurement outcome is asserted.</param>
            <param name="qubits">A register on which to make the assertion.</param>
            <param name="result">The expected result of <c>Measure(bases, qubits)</c> </param>
            <param name="msg">A message to be reported if the assertion fails.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.AssertProb(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},System.Double,System.String,System.Double)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.assertprob">Microsoft.Quantum.Intrinsic.AssertProb</a> is called in Q#.
            </summary>
            <remarks>
            The names and the order of the parameters is similar to the corresponding Q# operation./
            </remarks>
            <param name="bases">A multi-qubit Pauli operator, for which the measurement outcome is asserted.</param>
            <param name="qubits">A register on which to make the assertion.</param>
            <param name="probabilityOfZero">The probability with which result Zero is expected.</param>
            <param name="msg">A message to be reported if the assertion fails.</param>
            <param name="tol">The precision with which the probability of Zero outcome is specified.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.OnOperationStart(Microsoft.Quantum.Simulation.Core.ICallable,Microsoft.Quantum.Simulation.Core.IApplyData)">
            <summary>
            Called before a call to any Q# operation.
            </summary>
            <param name="operation">Information about operation being called.</param>
            <param name="arguments">Information about the arguments passed to the operation.</param>
            <remarks>
            Implement this interface if you want to be notified every time a Q# operation starts.
            To get the fully qualified Q# name of operation being called use <see cref="P:Microsoft.Quantum.Simulation.Core.ICallable.FullName"/>.
            For the variant of operation, that is to find if Adjoint, Controlled or Controlled Adjoint being called use <see cref="P:Microsoft.Quantum.Simulation.Core.ICallable.Variant"/>.
            To get a sequence of all qubits passed to the operation use <see cref="P:Microsoft.Quantum.Simulation.Core.IApplyData.Qubits"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.OnOperationEnd(Microsoft.Quantum.Simulation.Core.ICallable,Microsoft.Quantum.Simulation.Core.IApplyData)">
            <summary>
            Called when returning from a call to any Q# operation.
            </summary>
            <param name="operation">Information about operation being called.</param>
            <param name="arguments">Information about the arguments passed to the operation.</param>
            <remarks>
            Implement this interface if you want to be notified every time a Q# operation ends.
            To get the fully qualified Q# name of operation being called use <see cref="P:Microsoft.Quantum.Simulation.Core.ICallable.FullName"/>.
            For the variant of operation, that is to find if Adjoint, Controlled or Controlled Adjoint being called use <see cref="P:Microsoft.Quantum.Simulation.Core.ICallable.Variant"/>.
            To get a sequence of all qubits passed to the operation use <see cref="P:Microsoft.Quantum.Simulation.Core.IApplyData.Qubits"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.OnFail(System.Runtime.ExceptionServices.ExceptionDispatchInfo)">
            <summary>
            Called when an exception occurs. This could be Fail statement in Q#, or any other exception.
            </summary>
            <param name="exceptionDispatchInfo">Information about exception that was raised.</param>
            <remarks>
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.OnAllocateQubits(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Called when qubits are allocated by Q# <a href="https://docs.microsoft.com/azure/quantum/user-guide/language/statements/quantummemorymanagement#use-statement"><c>use</c></a> block. 
            </summary>
            <param name="qubits">Qubits that are being allocated</param>.
            <remarks>
            Every qubit has a unique identifier <see cref="P:Microsoft.Quantum.Simulation.Core.Qubit.Id"/>.
            All newly allocated qubits are in |0âŸ© state.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.OnReleaseQubits(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Called when qubits are released in Q# in the end of <a href="https://docs.microsoft.com/azure/quantum/user-guide/language/statements/quantummemorymanagement#use-statement"><c>use</c></a> block. 
            </summary>
            <param name="qubits">Qubits that are being released</param>.
            <remarks>
            Every qubit has a unique identifier <see cref="P:Microsoft.Quantum.Simulation.Core.Qubit.Id"/>.
            All qubits are expected to be released in |0âŸ© state.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.OnBorrowQubits(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},System.Int64)">
            <summary>
            Called when qubits are borrowed by Q# <a href="https://docs.microsoft.com/azure/quantum/user-guide/language/statements/quantummemorymanagement#borrow-statement"><c>borrow</c></a> block. 
            </summary>
            <param name="qubits">Qubits that are being borrowed</param>.
            <param name="allocatedForBorrowingCount">Number of qubits that have been allocated for borrowing. This might happen if there have not been enough already allocated qubits available for borrowing.</param>.
            <remarks>
            Every qubit has a unique identifier <see cref="P:Microsoft.Quantum.Simulation.Core.Qubit.Id"/>.
            Borrowed qubits can be in any state.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.OnReturnQubits(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},System.Int64)">
            <summary>
            Called when qubits are returned in the end of Q# <a href="https://docs.microsoft.com/azure/quantum/user-guide/language/statements/quantummemorymanagement#borrow-statement"><c>borrow</c></a> block. 
            </summary>
            <param name="qubits">Qubits that have been borrowed and are now being returned</param>.
            <param name="releasedOnReturnCount">Number of qubits that have been released once returned. This might happen if they have been allocated only for borrowing.</param>.
            <remarks>
            Every qubit has a unique identifier <see cref="P:Microsoft.Quantum.Simulation.Core.Qubit.Id"/>.
            Borrowed qubits are expected to be returned in the same state as the state they have been borrowed in.
            </remarks>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.OnDumpMachine``1(``0)">
            <summary>
            Called when 
            <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.diagnostics.dumpmachine">Microsoft.Quantum.Diagnostics.DumpMachine</a>
            is called in Q#.
            </summary>
            <remarks>
            The names and the order of the parameters are similar to corresponding Q# operation. 
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="location">Provides information on where to generate the DumpMachine state.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.OnDumpRegister``1(``0,Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Called when 
            <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.diagnostics.dumpregister">Microsoft.Quantum.Diagnostics.DumpRegister</a>
            is called in Q#.
            </summary>
            <remarks>
            The names and the order of the parameters are similar to corresponding Q# operation. 
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="location">Provides information on where to generate the DumpRegister state.</param>
            <param name="qubits">The list of qubits to report. </param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQuantumProcessor.OnMessage(System.String)">
            <summary>
            Called when <a href="https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.message">Microsoft.Quantum.Intrinsic.Message</a> is called in Q#.
            </summary>
            <remarks>
            The names and the order of the parameters are the same as corresponding Q# operations. 
            </remarks>
            <param name="msg">The message to be reported.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQubitManager.OnOperationStart(Microsoft.Quantum.Simulation.Core.ICallable,Microsoft.Quantum.Simulation.Core.IApplyData)">
            <summary>
            Callback to notify QubitManager that an operation execution has started. 
            This helps manage qubits scope.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.IQubitManager.OnOperationEnd(Microsoft.Quantum.Simulation.Core.ICallable,Microsoft.Quantum.Simulation.Core.IApplyData)">
            <summary>
            Callback to notify QubitManager that an operation execution has ended. 
            This helps manage qubits scope.
            </summary>
        </member>
        <member name="T:Microsoft.Quantum.Simulation.Common.UnsupportedOperationException">
            <summary>
            A class that implements exception to be thrown when Operation is not supported.
            </summary>
        </member>
        <member name="T:Microsoft.Quantum.Simulation.Common.SourceLinkInfo">
            <summary>
            Class for source link information corresponding to SourceLink schema 
            https://github.com/dotnet/designs/blob/master/accepted/diagnostics/source-link.md#source-link-json-schema
            </summary>
        </member>
        <member name="F:Microsoft.Quantum.Simulation.Common.SourceLinkInfo.patterns">
            <summary>
            Collection of patterns present within documents 
            </summary>
            <remarks>
            For example, documents can contain patterns with *, like shown below
            <code>
            { "documents": { "C:\\src\\CodeFormatter\\*": "https://raw.githubusercontent.com/dotnet/codeformatter/bcc51178e1a82fb2edaf47285f6e577989a7333f/*" },}
            </code>
            </remarks>
        </member>
        <member name="T:Microsoft.Quantum.Simulation.Common.PortablePdbSymbolReader">
            <summary>
            Utility class for extracting source file text and source location from PortablePDB meta-data.
            </summary>
            <remarks>
            Based on https://github.com/microsoft/BPerf/blob/master/WebViewer/Microsoft.BPerf.SymbolicInformation.ProgramDatabase/PortablePdbSymbolReader.cs
            </remarks>
        </member>
        <member name="F:Microsoft.Quantum.Simulation.Common.PortablePdbSymbolReader.SourceLink">
            <summary> SourceLink GUID is a part of PortablePDB meta-data specification https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#SourceLink </summary>
        </member>
        <member name="F:Microsoft.Quantum.Simulation.Common.PortablePdbSymbolReader.EmbeddedSource">
            <summary> EmbeddedSource GUID is a part of PortablePDB meta-data specification https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#embedded-source-c-and-vb-compilers </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.PortablePdbSymbolReader.GetEmbeddedFiles(System.String)">
            <summary>
            Unpacks all files stored in a PortablePDB meta-data. The key in the dictionary is the location of a source file 
            on the build machine. The value is the content of the source file itself.
            The function will throw an exception if PortablePDB file is not found or anything else went wrong.
            </summary>
            <param name="pdbFilePath">Path to PortablePDB file to load source files from.</param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.PortablePdbSymbolReader.GetSourceLinkInfo(System.String)">
            <summary>
            Returns SourceLink information, that is the source link information as described at https://github.com/dotnet/designs/blob/master/accepted/diagnostics/source-link.md#source-link-json-schema
            stored in PortablePDB.
            The function will throw an exception if PortablePDB file is not found or anything else went wrong.
            </summary>
            <param name="pdbFilePath">Path to PortablePDB file </param>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.PortablePdbSymbolReader.TryFormatGitHubUrl(System.String,System.Int32)">
            <summary>
            Includes line number into GitHub URL with source location
            </summary>
            <param name="rawUrl">Tuple of baseURL describing the repository and commit and relative path to the file</param>
            <param name="lineNumber">Line number to include into URL</param>
            <returns>GitHub URL for the file with the line number</returns>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.PortablePdbSymbolReader.GetPDBLocation(Microsoft.Quantum.Simulation.Core.ICallable)">
            <summary>
            Returns location of PortablePDB file with the source information for a given callable.
            Returns null if PortablePDB cannot be found.
            </summary>
        </member>
        <member name="T:Microsoft.Quantum.Simulation.Common.PortablePDBSourceLinkInfoCache">
            <summary>
            Caches path remapping from build machine to URL per location of PDB file.
            </summary>
        </member>
        <member name="F:Microsoft.Quantum.Simulation.Common.PortablePDBSourceLinkInfoCache._cache">
            <summary>
            Key is the location of a PortablePDB file on a current machine
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.PortablePDBSourceLinkInfoCache.TryGetFileUrl(System.String,System.String)">
            <summary>
            Finds URL for given path on a build machine.
            </summary>
        </member>
        <member name="T:Microsoft.Quantum.Simulation.Common.PortablePDBEmbeddedFilesCache">
            <summary>
            Caches sources of source files per location of PDB file indexed by source file path
            </summary>
        </member>
        <member name="F:Microsoft.Quantum.Simulation.Common.PortablePDBEmbeddedFilesCache._cache">
            <summary>
            Key is the location of a PortablePDB file on a current machine.
            Value is the dictionary returned by <see cref="M:Microsoft.Quantum.Simulation.Common.PortablePdbSymbolReader.GetEmbeddedFiles(System.String)"/>
            called with a given Key.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.PortablePDBEmbeddedFilesCache.GetEmbeddedFiles(System.String)">
            <summary>
            Returns cached result of calling <see cref="M:Microsoft.Quantum.Simulation.Common.PortablePdbSymbolReader.GetEmbeddedFiles(System.String)"/>
            </summary>
        </member>
        <member name="T:Microsoft.Quantum.Simulation.Common.QuantumProcessorBase">
            <summary>
            A class that implements IQuantumProcessor that does not do any logic, but is convenient to inherit from.
            It throws <see cref="T:Microsoft.Quantum.Simulation.Common.UnsupportedOperationException"/> for most APIs.
            </summary>
        </member>
        <member name="T:Microsoft.Quantum.Simulation.Common.QubitManager">
            <summary>
            Manages allocation, release, borrowing and return of qubits.
            Reuse of qubit Ids is allowed if they have been released.
            Allocation and release are O(1) operations.
            QubitManager uses memory - sizeof(long)*qubitCapacity. qubitCapacity is passed in to the constructor.
            </summary>
        </member>
        <member name="F:Microsoft.Quantum.Simulation.Common.QubitManager.NumQubits">
            <summary>
            Total number of qubits this QubitManager is capable of handling.
            </summary>
        </member>
        <member name="F:Microsoft.Quantum.Simulation.Common.QubitManager.NumAllocatedQubits">
            <summary>
            The number of currently allocated qubits.
            </summary>
        </member>
        <member name="F:Microsoft.Quantum.Simulation.Common.QubitManager.NumDisabledQubits">
            <summary>
            The number of disabled qubits.
            </summary>
        </member>
        <member name="F:Microsoft.Quantum.Simulation.Common.QubitManager.qubits">
            <summary>
            Tracks the allocation state of all qubits.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.#ctor(System.Int64,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates and initializes QubitManager that can handle up to numQubits qubits
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.CreateQubitObject(System.Int64)">
            <summary>
            May be overriden to create a custom Qubit object of a derived type.
            </summary>
            <param name="id">unique qubit id</param>
            <returns>a newly instantiated qubit</returns>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Disable(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Disables a given qubit.
            Once a qubit is disabled it can never be reallocated.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Disable(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Disables a set of given qubits.
            Once a qubit is disabled it can never be reallocated.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Allocate(System.Boolean)">
            <summary>
            Allocates a qubit.
            Returns null if the qubit cannot be allocated.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Allocate">
            <summary>
            Allocates a qubit.
            Throws a NotEnoughQubits exception if the qubit cannot be allocated. 
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Allocate(System.Int64)">
            <summary>
            Allocates numToAllocate new qubits.
            Throws a NotEnoughQubits exception without allocating any qubits if the qubits cannot be allocated. 
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Release(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Releases a given qubit.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Release(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Releases a set of given qubits.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Borrow(System.Collections.Generic.Stack{Microsoft.Quantum.Simulation.Core.Qubit},System.Int64,System.Int64)">
            <summary>
            Returns a qubit that is allocated, not disabled, and not listed as in use, whose id is in [minId, maxId).
            </summary>
            <param name="qubitsInUseSortedById">Contains the qubits that cannot be borrowed, where the qubits with the lowest ids are queued first.</param>
            <param name="minId">Only qubits whose id is larger or equal to minId will be considered for borrowing. Set to 0 if unspecified.</param>
            <param name="maxId">Only qubits whose id is smaller than maxId will be considered for borrowing. Set to NumQubits if unspecified.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Borrow(System.Int64)">
            <summary>
            Borrows a number of qubits. Chooses them from among already allocated ones.
            If there are not enough qubits to borrow, allocates new ones.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Return(Microsoft.Quantum.Simulation.Core.Qubit)">
            <summary>
            Returns a given borrowed qubit.
            Releases it if it has been allocated just for borrowing.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.QubitManager.Return(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit})">
            <summary>
            Returns a set of borrowed qubits given.
            Releases those that have been allocated just for borrowing.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.CommonUtils.PruneObservable(Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Pauli},Microsoft.Quantum.Simulation.Core.IQArray{Microsoft.Quantum.Simulation.Core.Qubit},Microsoft.Quantum.Simulation.Core.QArray{Microsoft.Quantum.Simulation.Core.Pauli}@,Microsoft.Quantum.Simulation.Core.QArray{Microsoft.Quantum.Simulation.Core.Qubit}@)">
            <summary>
            Removes PauliI terms from observable and corresponding qubits from qubits. 
            Returns the observable description that is equivalent to the original one, but has no PauliI terms
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.CommonUtils.PrunedSequence``2(Microsoft.Quantum.Simulation.Core.IQArray{``0},``0,Microsoft.Quantum.Simulation.Core.IQArray{``1})">
            <summary>
            Returns IEnumerable&lt;T&gt; that contains sub-sequence of <paramref name="sequenceToPrune"/>[i], such that <paramref name="sequence"/>[i] is not equal to <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.CommonUtils.Reduce(System.Int64,System.Int64)">
            <summary>
            Converts numbers of the form <paramref name="numerator"/>/2^<paramref name="denominatorPower"/> into canonical form where <paramref name="numerator"/> is odd or zero.
            If <paramref name="numerator"/> is zero, <paramref name="denominatorPower"/> must also be zero in the canonical form.
            </summary>
        </member>
        <member name="M:Microsoft.Quantum.Simulation.Common.CommonUtils.SampleDistribution(Microsoft.Quantum.Simulation.Core.IQArray{System.Double},System.Double)">
            <summary>
            Takes an array of doubles as
            input, and returns a randomly-selected index into the array 
            as an `Int`. The probability of selecting a specific index
            is proportional to the value of the array element at that index.
            Array elements that are equal to zero are ignored and their indices
            are never returned.If any array element is less than zero, or if
            no array element is greater than zero, then the operation fails.
            As a source of randomness uses a number uniformly distributed between 0 and 1. 
            Used for Quantum.Intrinsic.Random
            </summary>
            <param name="uniformZeroOneSample"> Number between Zero and one, uniformly distributed</param>
        </member>
    </members>
</doc>
